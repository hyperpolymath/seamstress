use anyhow::{anyhow, Context, Result};
use camino::Utf8PathBuf;
use walkdir::WalkDir;

use crate::model::SeamRecord;

fn default_root() -> Utf8PathBuf {
    Utf8PathBuf::from(".")
}

fn default_out() -> Utf8PathBuf {
    Utf8PathBuf::from("seams/reports/seams-report.adoc")
}

fn discover(root: &Utf8PathBuf) -> Vec<Utf8PathBuf> {
    let mut files = vec![];
    for e in WalkDir::new(root).into_iter().filter_map(|e| e.ok()) {
        let p = e.path();
        if !p.is_file() {
            continue;
        }
        let s = p.to_string_lossy();
        let is_candidate_dir = s.contains("/seams/records/") || (s.contains("/targets/") && s.contains("/seams/records/"));
        if !is_candidate_dir {
            continue;
        }
        if s.ends_with(".seam.json") {
            if let Ok(up) = Utf8PathBuf::from_path_buf(p.to_path_buf()) {
                files.push(up);
            }
        }
    }
    files.sort();
    files
}

fn risk_flags(rec: &SeamRecord) -> Vec<String> {
    let mut flags = vec![];
    if rec.test_vectors.is_empty() {
        flags.push("no_test_vectors".into());
    }
    if rec.checks.no_hidden_channels.status.to_lowercase() != "done" {
        flags.push("no_hidden_channels_not_done".into());
    }
    if rec.failure_behavior.backpressure.trim().is_empty() || rec.failure_behavior.backpressure == "TODO" {
        flags.push("backpressure_unspecified".into());
    }
    if rec.observability.metrics.is_empty() {
        flags.push("no_metrics".into());
    }
    if rec.compat_policy.deprecation_window_days < 1 {
        flags.push("bad_deprecation_window".into());
    }
    flags
}

pub fn run(root: Option<&str>, out: Option<&str>) -> Result<()> {
    let root = root.map(Utf8PathBuf::from).unwrap_or_else(default_root);
    let out = out.map(Utf8PathBuf::from).unwrap_or_else(default_out);

    let files = discover(&root);
    if files.is_empty() {
        return Err(anyhow!("no seam records found"));
    }

    let mut rows = vec![];

    for f in files {
        let raw = std::fs::read_to_string(&f).with_context(|| format!("read {f}"))?;
        let rec: SeamRecord = serde_json::from_str(&raw).with_context(|| format!("decode {f}"))?;
        let flags = risk_flags(&rec).join(", ");
        rows.push((rec.id, rec.title, rec.status, rec.side_a, rec.side_b, flags));
    }

    let mut doc = String::new();
    doc.push_str("= Seam Report\n:toc:\n\n");
    doc.push_str("== Inventory\n\n");
    doc.push_str("[cols="1,3,1,2,2,2",options="header"]\n|===\n");
    doc.push_str("|ID |Title |Status |Side A |Side B |Risk flags\n");
    for (id, title, status, a, b, flags) in rows {
        doc.push_str(&format!("|{id} |{title} |{status} |{a} |{b} |{flags}\n"));
    }
    doc.push_str("|===\n\n");
    doc.push_str("== Notes\n\nGenerated by seamctl report.\n");

    if let Some(parent) = out.parent() {
        std::fs::create_dir_all(parent)?;
    }
    std::fs::write(&out, doc)?;
    println!("Wrote {out}");
    Ok(())
}
